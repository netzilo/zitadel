---
title: ZITADEL API Reference Overview
sidebar_label: Overview
---

import { ApiCard } from "../../src/components/apicard";
import Column from "../../src/components/column";
import CodeBlock from "@theme/CodeBlock";
import ActionServiceProto from "!!raw-loader!./_v3_action_service.proto";
import ActionExecutionProto from "!!raw-loader!./_v3_action_execution.proto";
import ActionTargetProto from "!!raw-loader!./_v3_action_target.proto";
import ActionSearchProto from "!!raw-loader!./_v3_action_search.proto";
import IDPServiceProto from "!!raw-loader!./_v3_idp_service.proto";
import IDPProto from "!!raw-loader!./_v3_idp.proto";
import IDPSearchProto from "!!raw-loader!./_v3_idp_search.proto";
import IDPGitLabProto from "!!raw-loader!./_v3_idp_gitlab.proto";
import LanguageServiceProto from "!!raw-loader!./_v3_language_service.proto";
import LanguageProto from "!!raw-loader!./_v3_language.proto";
import ObjectProto from "!!raw-loader!./_v3_object.proto";
import ResourceObjectProto from "!!raw-loader!./_v3_resource_object.proto";
import SettingsObjectProto from "!!raw-loader!./_v3_settings_object.proto";

ZITADEL exposes all features via different gRPC and REST APIs and provides SDKs for popular languages and frameworks.

The [OpenID Connect & OAuth endpoints](/docs/apis/openidoauth/endpoints) and [SAML 2.0 endpoints](/docs/apis/saml/endpoints) are implemented and exposed according to the specific standards. Managing resources such as users, organizations, instances, or settings must be done with the different [ZITADEL APIs](#zitadel-apis-resource-based).

[Actions](/docs/apis/actions/introduction) allow to extend ZITADEL with custom code to change default behaviors or calling external systems.

## Authentication & authorization

### Authentication for human users (interactive)

ZITADEL implements industry standards such as OpenID Connect, OAuth 2.0, or SAML for authentication.
Please refer to our guides how to [authenticate users](/docs/guides/integrate/login/login-users) through an interactive authentication process.

For user authentication on devices with limited accessibility (eg, SmartTV, Smart Watch etc.) use the [device authorization grant](/docs/guides/integrate/login/oidc/device-authorization).

Additionally, you can use the [session API](../apis/resources/session_service_v2/) to authenticate users, for example by building a [custom login UI](/docs/guides/integrate/login-ui/).

### Authenticate service users and machines

Service users allow for machine-to-machine (M2M) communication.
Follow the guides to learn how to [authenticate service users](/docs/guides/integrate/service-users/authenticate-service-users).

Accessing the ZITADEL APIs through a service user might require additional steps, please follow the guide on how to [access ZITADEL APIs](../guides/integrate/zitadel-apis/access-zitadel-apis) to include the correct audience scope in your requests.

### OpenID Connect & OAuth

- [OpenID Connect endpoints](/docs/apis/openidoauth/endpoints) definition
- Standard and reserved [scopes reference](/docs/apis/openidoauth/scopes)
- Standard, custom, and reserved [claims reference](/docs/apis/openidoauth/claims)

The [OIDC Playground](/docs/apis/openidoauth/authrequest) is for testing OpenID authentication requests and their parameters.

### SAML 2.0

- [SAML 2.0 endpoints](/docs/apis/saml/endpoints) definition
- [Custom attributes](https://github.com/zitadel/actions/blob/main/examples/set_custom_attribute.js) can be added with an action

### Custom

ZITADEL allows to authenticate users by creating a session with the [Session API](/docs/apis/resources/session_service_v2) or get OIDC authentication request details with the [OIDC service API](/docs/apis/resources/oidc_service_v2).
User authorizations can be [retrieved as roles from our APIs](/docs/guides/integrate/retrieve-user-roles).

Refer to our guide to learn how to [build your own login UI](/docs/guides/integrate/login-ui)

## ZITADEL APIs (resource-based)

Resource-Based APIs, are organized around data resources such as users, organizations, or projects.
They typically use a single authentication mechanism for all resources and check permissions at the resource level.
The context of a request is explicit and provided as part of the request, like a token or organization-id.

:::info
We are migrating to a resource-based API approach.
You might need to use the existing [service-based](#zitadel-api-v1-service-based) APIs for now to manage Organizations, Instances, Assets etc.
:::

### API V2


APIs V2 organize access by resources (users, settings, etc.), unlike context-specific V1 APIs.
This simplifies finding the right API, especially for multi-organization resources.

Users created with the V2 API have no initial state anymore, so new users are immediately active.
Requesting ZITADEL to send a verification email on user creation is still possible.

### API V3

The APIs described in this section are currently either in **alpha** stage or not implemented, yet.
Before using these APIs, pleases consider the [API release policy below](#api-release-policy)

#### We Appreciate your Help

We invite you to...

- ... [discuss the concept with the ZITADEL community on GitHub](https://github.com/zitadel/zitadel/discussions/8125).
- ... try the implementations and provide feedback [by filing issues on GitHub](https://github.com/zitadel/zitadel/issues/new/choose).

#### The Ideas behind the New V3 APIs

The ZITADEL Service-Based APIs are structured around contexts like System, Admin, Management, and Auth.
This structure leads to duplicate methods and makes it hard to find the right API for the right task.
Especially interacting with resources from multiple organizations is cumbersome.
Also, the APIs evolved over time, which lead to inconsistencies and a lack of flexibility in development.

We address these issues with the following new API categories:

- [Standard Resources](#standard-resources)
- [Reusable Resources](#reusable-resources)
- [Settings](#settings)

The designs for the new API categories aim for the following improvements:

##### Service Structure

Instead of structuring the API methods around contexts, new APIs are structured around resources and settings.
This means, we will deprecate the old System-, Admin-, Management- and AuthAPIs in favor of User-, Action-, Language-, FeatureAPIs and so on.
This change makes it easier to find the right API for the right task, especially for multi-organization resources.
Also, it allows for faster development and independent versioning of the APIs.

##### Multitenancy Management and Consistency

To improve managing and reusing resources and settings in multitenancy scenarios, we define some rules for the new APIs:

- Single properties from default settings are overridable (patchable) in organizations.
- Some settings support user-defined custom properties that are also overridable in organizations.
- Improved experience with reusing resources in multiple organizations and instances.
- Resources are searchable over all organizations with a single call by default.

##### HTTP and gRPC Consistency

To make the APIs more consistent and easier to use, we follow the same patterns in all Proto files.

- Patching is favored over updating resources and settings.
- HTTP calls are mapped so that query parameters can be used as much as possible. We avoid the annotation `body: "*"`.
- For search performance, we enforce query limits.

#### Standard Resources

Standard resources exist in exactly one context.
For example, a user is always assigned to exactly one organization.
Or one SMS provider is always assigned to exactly one instance.

Standard resource methods behave like this:

- Search request results can be scoped to a RequestContext.
- Search request results only contain results for which the requesting user has the necessary read permissions.
- Search requests are limited to 100 by default. The limit can be increased by the caller up to 1000 by default.
- Resource configurations are partially updatable. With HTTP, this is done via PATCH requests. If no changes were made, the response is successful.
- Status changes or other actions on resources with side effects are done via POST requests. Their HTTP path ends with the underscore prefixed action name. For example `POST /resources/users/{id}/_unlock`.

For a full proto example, have a look at the [ZITADELActions service](#zitadelactions).

#### Reusable Resources

Reusable resources are like standard resources but can be reused in multiple contexts.
For example, an external identity provider can be defined once on the instance.
Each organization within this instance can then choose to use this identity provider or not.

Additionally to the methods described for standard resources, reusable have the following capabilities:

Reusable resources have the same behavior as standard resources with the following additions:

- Reusable resources can be created in a given context level (system, instance, org).
- For requests, that require a resource ID, no request context is needed.
- Reusable resources are available in child contexts, even if their state is _inactive_.
- The child context can control if an inherited resource should be active or inactive for itself using a state policy.
- In child contexts, the state policy of a reused resource is _inherit_ by default and can be changed to _activate_, _deactivate_ or back to _inherit_.
- In child contexts, a reused resources configuration is read-only.
- Child contexts can read at least the following properties of reused resources:
- ID
- name
- description
- state
- the state policy in the child context
- sequence
- last changed date
- parent context
- state in the immediate parent context.
- By default, search queries for reused resources return all resources from the given contexts, all inherited resources and all resources defined in all children contexts.

Typically, a new resource is first designed and implemented as a non-reusable resource.
If the community sees a benefit in reusing the resource in multiple contexts, reusability is added to the resource.

For a full proto example, have a look at the [ZITADELIdentityProviders service](#zitadelidentityproviders).

#### Resource Services

All resource services by default support the following CRUD operations [as described above](#standard-resources).

- Create
- Read (get, search)
- Patch (partially update, success on no changes)
- Delete

##### ZITADELActions

- Standard CRUD methods for Targets
- Standard CRUD methods for Executions except the PutExecution method replaces the CreateExecution and PatchExecution methods

Additional to the standard CRUD methods:

- ListAvailableExecutionServices
- ListAvailableExecutionMethods
- ListAvailableExecutionFunctions

<details>
    <summary>action_service.proto</summary>
    <CodeBlock language="protobuf">{ActionServiceProto}</CodeBlock>
</details>

<details>
    <summary>action_target.proto</summary>
    <CodeBlock language="protobuf">{ActionTargetProto}</CodeBlock>
</details>

<details>
    <summary>action_execution.proto</summary>
    <CodeBlock language="protobuf">{ActionExecutionProto}</CodeBlock>
</details>

<details>
    <summary>action_query.proto</summary>
    <CodeBlock language="protobuf">{ActionSearchProto}</CodeBlock>
</details>

##### ZITADELUsers

Standard CRUD methods

##### ZITADELUserSchemas

Standard CRUD methods

##### ZITADELIdentityProviders

- Standard CRUD and methods for all IDPs
- Resources have additional properties for reusability capabilities.

<details>
    <summary>idp_service.proto</summary>
    <CodeBlock language="protobuf">{IDPServiceProto}</CodeBlock>
</details>

<details>
    <summary>idp.proto</summary>
    <CodeBlock language="protobuf">{IDPProto}</CodeBlock>
</details>

<details>
    <summary>idp_search.proto</summary>
    <CodeBlock language="protobuf">{IDPSearchProto}</CodeBlock>
</details>

<details>
    <summary>idp_gitlab.proto</summary>
    <CodeBlock language="protobuf">{IDPGitLabProto}</CodeBlock>
</details>

<details>
    <summary>object.proto</summary>
    <CodeBlock language="protobuf">{ObjectProto}</CodeBlock>
</details>

<details>
    <summary>resource_object.proto</summary>
    <CodeBlock language="protobuf">{ResourceObjectProto}</CodeBlock>
</details>

##### ZITADELInstances

Additional to the standard CRUD methods:

- Limit (partial update of block and audit log retention)
- BulkLimit (partial update of block and audit log retention for multiple instances)

##### ZITADELOrganizations

Additional to the standard CRUD methods:

- SetAsInstanceDefault
- GetInstanceDefault

##### ZITADELDomains

Additional to the standard CRUD methods:

- SetAsPrimary
- Validate

##### ZITADELSessions

Standard CRUD methods

##### ZITADELProjects

Standard CRUD methods

##### ZITADELApps

Standard CRUD methods

##### ZITADELMemberships

The given context defines the organization, instance or system where the membership is created.
The context and the user ID together are unique.

Additional to the standard CRUD methods:

- ListAvailableRoles (context-aware)

##### ZITADELGrants

- Standard CRUD methods for project grants
- Standard CRUD methods for user grants
- Standard CRUD methods for roles

##### ZITADELSMTPProviders

Standard CRUD methods

##### ZITADELSMSProviders

Standard CRUD methods

#### Settings

Settings have no identity (ID) and are always context-aware.
They also don't have a state like active or inactive.
They only have properties that can be set and queried.
These properties are inherited to from parent-contexts (instance) to child-contexts (organization).

Settings behave like this:

- Setting and retrieving settings is always context-aware. By default, the context is the instance discovered by the requests _Host_ header.
- All settings properties can be partially overridden in child-contexts.
- All settings properties can be partially reset in child-contexts, so their values default to the parent contexts property values.
- All settings properties returned by queries contain the value and if it is inherited, the context where it is inherited from.

For a full proto example, have a look at the [ZITADELLanguageSettings service](#zitadellanguagesettings).

#### Settings Services

##### ZITADELLanguageSettings

Default language, restricted languages, supported languages

<details>
    <summary>language_service.proto</summary>
    <CodeBlock language="protobuf">{LanguageServiceProto}</CodeBlock>
</details>

<details>
    <summary>language.proto</summary>
    <CodeBlock language="protobuf">{LanguageProto}</CodeBlock>
</details>

<details>
    <summary>object.proto</summary>
    <CodeBlock language="protobuf">{ObjectProto}</CodeBlock>
</details>

<details>
    <summary>settings_object.proto</summary>
    <CodeBlock language="protobuf">{SettingsObjectProto}</CodeBlock>
</details>

##### ZITADELTextSettings

Key-value pairs for localized login texts, previously known as login texts

##### ZITADELBrandingSettings

Predefined branding settings and custom key-value pairs, previously known as label policy or branding settings

##### ZITADELLoginSettings

Previously known as login policy

##### ZITADELLockoutSettings

Previously known as lockout policy

##### ZITADELPasswordSettings

Previously known as password complexity policy

##### ZITADELHelpSettings

Previously known as legal and support settings or privacy policy

##### ZITADELDomainSettings

Previously known as domain policy

##### ZITADELFeatureSettings

Feature toggles

Also contains disallow public org registrations on system and instance level.

##### ZITADELTemplatesSettings

HTML and text templates for fully customizable emails and sms

##### ZITADELSecretSettings

Replaces secret generators

#### API Release Policy

- Defined but not yet implemented APIs are subject to change without further notice.
- Once an API definition is implemented, it is released as _Preview_ and is available for testing.
- When a _Preview_ API is tested enough so the concepts are proven to work, a new _Beta_ API is released.
- When an API is feature-complete and stable enough, a new _GA_ (General Availability) API is released.
- In all stages, changes to already implemented APIs are done in a backwards-compatible way, if possible.
- When we release a new stage for an API, we deprecate the previous stage and keep it available for a smooth transition.

## ZITADEL API V1 (service-based)

Service-Based APIs are structured around specific services or functionalities.
Each service has its own authentication mechanism and permission rules.
For instance, the auth-API handles user self-management, while the management-API handles ressources in the context of an organization manager.
The context of a request is typically implicit and determined by the API being called.

:::info Prefer resource-based API
ZITADEL APIs were organized by UseCase/Context, such as Auth API for authenticated users and Management API for organization managers.
This led to confusion about which API to use, particularly for requests that could be useful across multiple APIs but with different filters.
For instance, SearchUsers on an Instance Level or on an Organization Level.

To address this issue, ZITADEL is migrating to a [resource-based API](#zitadel-apis-resource-based). 
:::

<ApiCard title="Authentication" type="AUTH">
<Column>
<div>

### Authentication

The authentication API (aka Auth API) is used for all operations on the currently logged in user. The user id is taken from the sub claim in the token.

</div>
<div className="apicard-right">

#### GRPC

Endpoint:
$ZITADEL_DOMAIN/zitadel.auth.v1.AuthService/

Definition:
[Auth Proto](https://github.com/zitadel/zitadel/blob/main/proto/zitadel/auth.proto)

#### REST

Endpoint:
$ZITADEL_DOMAIN/auth/v1/

API Reference:
[OpenAPI Docs](/apis/resources/auth)

</div>
</Column>
</ApiCard>

<ApiCard title="Management" type="MGMT">
<Column>

<div>

### Management

The management API is as the name states the interface where systems can mutate IAM objects like, organizations, projects, clients, users and so on if they have the necessary access rights.
To identify the current organization you can send a header `x-zitadel-orgid` or if no header is set, the organization of the authenticated user is set.

</div>
<div className="apicard-right">

#### GRPC

Endpoint:
$ZITADEL_DOMAIN/zitadel.management.v1.ManagementService/

Definition:
[Management Proto](https://github.com/zitadel/zitadel/blob/main/proto/zitadel/management.proto)

#### REST

Endpoint:
$ZITADEL_DOMAIN/management/v1/

API Reference:
[OpenAPI Docs](/apis/resources/mgmt)

</div>
</Column>
</ApiCard>

<ApiCard title="Administration" type="ADMIN">
<Column>
<div>

### Administration

This API is intended to configure and manage one ZITADEL instance itself.

</div>
<div className="apicard-right">

#### GRPC

Endpoint:
$ZITADEL_DOMAIN/zitadel.admin.v1.AdminService/

Definition:
[Admin Proto](https://github.com/zitadel/zitadel/blob/main/proto/zitadel/admin.proto)

#### REST

Endpoint:
$ZITADEL_DOMAIN/admin/v1/

API Reference:
[OpenAPI Docs](/apis/resources/admin)

</div>
</Column>
</ApiCard>

<ApiCard title="Administration" type="SYSTEM">
<Column>
<div>

### System

This API is intended to manage the different ZITADEL instances within the system.

Checkout the guide how to [access the ZITADEL System API](/docs/guides/integrate/zitadel-apis/access-zitadel-system-api).

</div>
<div className="apicard-right">

#### GRPC

Endpoint:
$ZITADEL_DOMAIN/zitadel.system.v1.SystemService/

Definition:
[System Proto](https://github.com/zitadel/zitadel/blob/main/proto/zitadel/system.proto)

#### REST

Endpoint:
$ZITADEL_DOMAIN/system/v1/

API Reference:
[OpenAPI Docs](/apis/resources/system)

</div>
</Column>
</ApiCard>

<ApiCard title="Assets" type="ASSET">
<Column>
<div>

### Assets

The Assets API allows you to up- and download all kinds of assets. This can be files such as logos, fonts or user avatar.

</div>
<div>

#### REST

Endpoint:
$ZITADEL_DOMAIN/assets/v1/

Definition:
[Assets](./assets/assets.md)

</div>
</Column>
</ApiCard>


## API definitions

Each service's proto definition is located in the source control on GitHub.
As we generate the REST services and Swagger file out of the proto definition we recommend that you rely on the proto file.
We annotate the corresponding REST methods on each possible call as well as the AuthN and AuthZ requirements.
The last API (assets) is only a REST API because ZITADEL uses multipart form data for certain elements.

### SDKs

ZITADEL provides some [official and community supported SDKs](/docs/sdk-examples/introduction) for multiple languages and frameworks.
Most languages allow you to build a client from proto definitions, which allows you to build your own client in case an SDK is missing.

### Proto

All of our APIs are generated by proto definitions. You can find all the proto definitions in the [Proto API Definitions](https://github.com/zitadel/zitadel/tree/main/proto/zitadel).

> More about [Protocol Buffer](https://developers.google.com/protocol-buffers)

### Swagger documentation

We provide some json files for the swagger documentation of our APIs with the following link: [https://zitadel.cloud/openapi/v2/swagger/](https://zitadel.cloud/openapi/v2/swagger/)

The easiest way to have a look at them is, to import them in the [Swagger Editor](https://editor.swagger.io/)

### Example

See below for an example with the call **GetMyUser**.

```go
  //User
  rpc GetMyUser(google.protobuf.Empty) returns (UserView) {
    option (google.api.http) = {
      get: "/users/me"
    };

    option (zitadel.v1.auth_option) = {
      permission: "authenticated"
    };
  }
```

As you can see the `GetMyUser` function is also available as a REST service under the path `/users/me`.

In the table below you can see the URI of those calls.

| Service | URI                                                 |
| :------ | :-------------------------------------------------- |
| REST    | $ZITADEL_DOMAIN/auth/v1/users/me                      |
| GRPC    | $ZITADEL_DOMAIN/zitadel.auth.v1.AuthService/GetMyUser |

## Domains

ZITADEL hosts everything under a single domain: `{instance}.zitadel.cloud` or your custom domain `$ZITADEL_DOMAIN`

The domain is used as the OIDC issuer and as the base url for the gRPC and REST APIs, the Login and Console UI, which you'll find under `{your_domain}/ui/console/`.

Are you self-hosting and having troubles with *Instance not found* errors? [Check out this page](/docs/self-hosting/manage/custom-domain).

## API path prefixes

If you run ZITADEL on a custom domain, you may want to reuse that domain for other applications.
For easy copying to your reverse proxy configuration, here is the list of URL path prefixes, ZITADEL uses.

```yaml
/zitadel.admin.v1.AdminService/
/admin/v1/
/zitadel.auth.v1.AuthService/
/auth/v1/
/zitadel.management.v1.ManagementService/
/management/v1/
/zitadel.system.v1.SystemService/
/system/v1/
/assets/v1/
/ui/
/oidc/v1/
/saml/v2/
/oauth/v2/
/device
/.well-known/openid-configuration
/openapi/
/idps/callback
/v2beta/
/zitadel.user.v2beta.UserService/
/zitadel.session.v2beta.SessionService/
/zitadel.settings.v2beta.SettingsService/
/zitadel.oidc.v2beta.OIDCService/
/zitadel.org.v2beta.OrganizationService/
/v2/
/zitadel.user.v2.UserService/
/zitadel.session.v2.SessionService/
/zitadel.settings.v2.SettingsService/
/zitadel.oidc.v2.OIDCService/
/zitadel.org.v2.OrganizationService/
```
